module;
#include <libassert/assert-macros.hpp>
#include <spdlog/sinks/stdout_color_sinks.h>
#include <spdlog/spdlog.h>
#include <vulkan/vulkan_hpp_macros.hpp>
export module svl.platform.device:gpu;

import svl.utils;

import libassert;
import vulkan;

export namespace svl::platform::device
{
class gpu final
{
public:
    gpu() = default;
    gpu(vk::PhysicalDevice       phys_device,
        vk::SurfaceKHR           surface,
        std::vector<std::string> requested_ext)
        : phys_device(phys_device)
    {
        phys_device.getFeatures2(&features);
        phys_device.getProperties2(&properties);
        phys_device.getMemoryProperties2(&memory_properties);

        {
            uint32_t count { 0 };
            phys_device.getQueueFamilyProperties(&count, nullptr);
            queue_family_properties.resize(count);
            phys_device.getQueueFamilyProperties(
                &count, queue_family_properties.data());
        }

        {
            uint32_t propertyCount { 0 };
            utils::vk_check(phys_device.enumerateDeviceExtensionProperties(
                nullptr, &propertyCount, nullptr));

            std::vector<vk::ExtensionProperties> properties(propertyCount);
            utils::vk_check(phys_device.enumerateDeviceExtensionProperties(
                nullptr, &propertyCount, properties.data()));

            std::ranges::transform(
                properties,
                std::back_inserter(extensions),
                [](const vk::ExtensionProperties& property)
                { return std::string(property.extensionName); });

            std::ranges::sort(extensions);
            std::ranges::sort(requested_ext);
            std::vector<std::string> enabled_ext_vec;
            std::ranges::set_intersection(
                extensions, requested_ext, std::back_inserter(enabled_ext_vec));
            enabled_ext = { enabled_ext_vec.begin(), enabled_ext_vec.end() };
        }

        if (surface != nullptr)
        {
            enumerateSurfaceFormats(surface);
            enumerateSurfaceCapabilities(surface);
            enumeratePresentationModes(surface);
        }

        spdlog::info("Selected GPU: {} {} ({}) - Vulkan {}",
                     properties.properties.deviceName.data(),
                     properties.properties.vendorID,
                     properties.properties.deviceID,
                     properties.properties.apiVersion);

        auto logger = spdlog::stdout_color_mt("stdout");
        logger->set_pattern("%v");

        spdlog::info("Extensions:");
        for (const auto& ext : extensions)
        {
            logger->info("{}", ext);
        }
        spdlog::info("Supported surface formats: ");
        for (const auto format : surface_formats)
        {
            logger->info("{} : {}",
                         vk::to_string(format.format),
                         vk::to_string(format.colorSpace));
        }

        spdlog::info("Supported presentation modes: ");
        for (const auto mode : present_modes)
        {

            logger->info("{}", vk::to_string(mode));
        }
    }
    [[nodiscard]] const vk::PhysicalDevice device() const noexcept
    {
        return phys_device;
    }
    void reserve_queues(vk::QueueFlags requested_queue_types,
                        vk::SurfaceKHR surface)
    {
        ASSERT(static_cast<bool>(requested_queue_types),
               "Requested queue types is empty");

        for (uint32_t queue_family_index = 0;
             queue_family_index < queue_family_properties.size() &&
             static_cast<bool>(requested_queue_types);
             ++queue_family_index)
        {
            if (!presentation_family_index.has_value() && surface)
            {
                vk::Bool32 supports_present { false };
                utils::vk_check(phys_device.getSurfaceSupportKHR(
                    queue_family_index, surface, &supports_present));

                if (supports_present == true)
                {
                    presentation_family_index = queue_family_index;
                    presentation_queue_count =
                        queue_family_properties[queue_family_index].queueCount;
                }
            }
            if (!graphics_family_index.has_value() &&
                (requested_queue_types &
                 queue_family_properties[queue_family_index].queueFlags) &
                    vk::QueueFlagBits::eGraphics)
            {
                graphics_family_index = queue_family_index;
                graphics_queue_count =
                    queue_family_properties[queue_family_index].queueCount;
                requested_queue_types &= ~vk::QueueFlagBits::eGraphics;
                continue;
            }

            if (!compute_family_index.has_value() &&
                (requested_queue_types &
                 queue_family_properties[queue_family_index].queueFlags) &
                    vk::QueueFlagBits::eCompute)
            {
                compute_family_index = queue_family_index;
                compute_queue_count =
                    queue_family_properties[queue_family_index].queueCount;
                requested_queue_types &= ~vk::QueueFlagBits::eCompute;
                continue;
            }

            if (!transfer_family_index.has_value() &&
                (requested_queue_types &
                 queue_family_properties[queue_family_index].queueFlags) &
                    vk::QueueFlagBits::eTransfer)
            {
                transfer_family_index = queue_family_index;
                transfer_queue_count =
                    queue_family_properties[queue_family_index].queueCount;
                requested_queue_types &= ~vk::QueueFlagBits::eTransfer;
                continue;
            }

            if (!sparse_family_index.has_value() &&
                (requested_queue_types &
                 queue_family_properties[queue_family_index].queueFlags) &
                    vk::QueueFlagBits::eSparseBinding)
            {
                sparse_family_index = queue_family_index;
                sparse_queue_count =
                    queue_family_properties[queue_family_index].queueCount;
                requested_queue_types &= ~vk::QueueFlagBits::eSparseBinding;
                continue;
            }
        }

        ASSERT(graphics_family_index.has_value() ||
                   compute_family_index.has_value() ||
                   transfer_family_index.has_value() ||
                   sparse_family_index.has_value(),
               "No suitable queue(s) found");

        ASSERT(!surface || presentation_family_index.has_value(),
               "No queues with presentation capabilities found");
    }

    [[nodiscard]] std::vector<std::pair<uint32_t, uint32_t>>
    queue_family_index_and_count() const
    {
        std::set<std::pair<uint32_t, uint32_t>> family_indices;
        if (graphics_family_index.has_value())
        {
            family_indices.insert(
                { graphics_family_index.value(), graphics_queue_count });
        }
        if (compute_family_index.has_value())
        {
            family_indices.insert(
                { compute_family_index.value(), compute_queue_count });
        }
        if (transfer_family_index.has_value())
        {
            family_indices.insert(
                { transfer_family_index.value(), transfer_queue_count });
        }
        if (sparse_family_index.has_value())
        {
            family_indices.insert(
                { sparse_family_index.value(), sparse_queue_count });
        }
        if (presentation_family_index.has_value())
        {
            family_indices.insert({ presentation_family_index.value(),
                                    presentation_queue_count });
        }
        return { family_indices.begin(), family_indices.end() };
    }

    [[nodiscard]] const bool graphics_family_enabled() const noexcept
    {
        return graphics_family_index.has_value();
    }
    [[nodiscard]] const uint32_t get_graphics_family_index() const
    {
        ASSERT(graphics_family_enabled(),
               "Try get graphics family index when it family disabled");
        return graphics_family_index.value();
    }
    [[nodiscard]] const uint32_t get_graphics_queue_count() const noexcept
    {
        return graphics_queue_count;
    }
    [[nodiscard]] const bool compute_family_enabled() const noexcept
    {
        return compute_family_index.has_value();
    }
    [[nodiscard]] const uint32_t get_compute_family_index() const
    {
        ASSERT(compute_family_enabled(),
               "Try get compute family index when it family disabled");
        return compute_family_index.value();
    }
    [[nodiscard]] const uint32_t get_compute_queue_count() const noexcept
    {
        return compute_queue_count;
    }

private:
    void enumerateSurfaceFormats(vk::SurfaceKHR surface)
    {
        uint32_t count { 0 };
        utils::vk_check(
            phys_device.getSurfaceFormatsKHR(surface, &count, nullptr));
        surface_formats.resize(count);
        utils::vk_check(phys_device.getSurfaceFormatsKHR(
            surface, &count, surface_formats.data()));
    }
    void enumerateSurfaceCapabilities(vk::SurfaceKHR surface)
    {
        utils::vk_check(phys_device.getSurfaceCapabilitiesKHR(
            surface, &surface_capabilities));
    }
    void enumeratePresentationModes(vk::SurfaceKHR surface)
    {
        std::uint32_t count { 0 };
        utils::vk_check(
            phys_device.getSurfacePresentModesKHR(surface, &count, nullptr));
        present_modes.resize(count);
        utils::vk_check(phys_device.getSurfacePresentModesKHR(
            surface, &count, present_modes.data()));
    }

    vk::PhysicalDevice       phys_device {};
    std::vector<std::string> extensions;

    vk::PhysicalDeviceProperties2 properties = {};

    vk::PhysicalDeviceFeatures2         features = {};
    vk::PhysicalDeviceMemoryProperties2 memory_properties;

    std::vector<vk::QueueFamilyProperties> queue_family_properties;

    // Swapchain support
    std::vector<vk::SurfaceFormatKHR> surface_formats;
    vk::SurfaceCapabilitiesKHR        surface_capabilities;
    std::vector<vk::PresentModeKHR>   present_modes;
    std::unordered_set<std::string>   enabled_ext;

    std::optional<uint32_t> presentation_family_index;
    uint32_t                presentation_queue_count {};
    std::optional<uint32_t> graphics_family_index;
    uint32_t                graphics_queue_count {};
    std::optional<uint32_t> compute_family_index;
    uint32_t                compute_queue_count {};
    std::optional<uint32_t> transfer_family_index;
    uint32_t                transfer_queue_count {};
    std::optional<uint32_t> sparse_family_index;
    uint32_t                sparse_queue_count {};
};
} // namespace svl::platform::device