module;
#include <SDL3/SDL.h>
#include <SDL3/SDL_vulkan.h>
#include <spdlog/spdlog.h>
#include <vulkan/vulkan_hpp_macros.hpp>

#include "svl_config.hxx"
export module svl.platform.window;

import svl.platform.device;
import svl.utils;

import std;
import vulkan;

export namespace svl::platform::window
{
class window_error : public std::exception
{
public:
    explicit window_error(std::string_view msg)
        : message(msg)
    {
    }
    [[nodiscard]] const char* what() const noexcept override
    {
        return message.data();
    }

private:
    std::string_view message {};
};
class context final
{
public:
    using flags = std::uint64_t;
    enum class flag : flags
    {
        FULLSCREEN          = SDL_WINDOW_FULLSCREEN,
        OCCLUDED            = SDL_WINDOW_OCCLUDED,
        HIDDEN              = SDL_WINDOW_HIDDEN,
        BORDERLESS          = SDL_WINDOW_BORDERLESS,
        RESIZABLE           = SDL_WINDOW_RESIZABLE,
        MINIMIZED           = SDL_WINDOW_MINIMIZED,
        MAXIMIZED           = SDL_WINDOW_MAXIMIZED,
        MOUSE_GRABBED       = SDL_WINDOW_MOUSE_GRABBED,
        INPUT_FOCUS         = SDL_WINDOW_INPUT_FOCUS,
        MOUSE_FOCUS         = SDL_WINDOW_MOUSE_FOCUS,
        EXTERNAL            = SDL_WINDOW_EXTERNAL,
        MODAL               = SDL_WINDOW_MODAL,
        HIGH_PIXEL_DENSITY  = SDL_WINDOW_HIGH_PIXEL_DENSITY,
        MOUSE_CAPTURE       = SDL_WINDOW_MOUSE_CAPTURE,
        MOUSE_RELATIVE_MODE = SDL_WINDOW_MOUSE_RELATIVE_MODE,
        ALWAYS_ON_TOP       = SDL_WINDOW_ALWAYS_ON_TOP,
        UTILITY             = SDL_WINDOW_UTILITY,
        TOOLTIP             = SDL_WINDOW_TOOLTIP,
        POPUP_MENU          = SDL_WINDOW_POPUP_MENU,
        KEYBOARD_GRABBED    = SDL_WINDOW_KEYBOARD_GRABBED,
        FILL_DOCUMENT       = SDL_WINDOW_FILL_DOCUMENT,
        TRANSPARENT         = SDL_WINDOW_TRANSPARENT,
        NOT_FOCUSABLE       = SDL_WINDOW_NOT_FOCUSABLE,
    };

    explicit context(std::string    window_title,
                     std::int32_t   window_width,
                     std::int32_t   window_height,
                     context::flags window_state)
        : width(window_width)
        , height(window_height)
        , state(window_state)
    {
        title = std::format("{} [{}]", window_title, svl::version::version);

        SDL_SetAppMetadataProperty(SDL_PROP_APP_METADATA_NAME_STRING,
                                   title.c_str());
        SDL_SetAppMetadataProperty(SDL_PROP_APP_METADATA_VERSION_STRING,
                                   svl::version::version.c_str());
        SDL_SetAppMetadataProperty(SDL_PROP_APP_METADATA_IDENTIFIER_STRING,
                                   svl::constants::appdata::identifier.c_str());
        SDL_SetAppMetadataProperty(SDL_PROP_APP_METADATA_CREATOR_STRING,
                                   svl::constants::appdata::creator.c_str());
        SDL_SetAppMetadataProperty(SDL_PROP_APP_METADATA_COPYRIGHT_STRING,
                                   svl::constants::appdata::copyright.c_str());
        SDL_SetAppMetadataProperty(SDL_PROP_APP_METADATA_URL_STRING,
                                   svl::constants::appdata::url.c_str());
        SDL_SetAppMetadataProperty(SDL_PROP_APP_METADATA_TYPE_STRING,
                                   svl::constants::appdata::type.c_str());

        if (!SDL_Init(SDL_INIT_VIDEO | SDL_INIT_EVENTS | SDL_INIT_AUDIO))
        {
            spdlog::error("Cant init SDL: {}", SDL_GetError());
            throw window_error("Window construct error");
        }
    }
    // TODO: Add posibility to create 2 or more windows with diff render
    // context, but common app logic and controls
    context([[maybe_unused]] const context& wnd) {}
    ~context()
    {
        destroy();
        SDL_Quit();
    }

    void create(std::vector<const char*> req_layers,
                std::vector<const char*> req_ext)
    {
        requested_layers = std::move(req_layers);
        requested_ext    = std::move(req_ext);
        if (running)
        {
            spdlog::warn("Window exist. Repeated call of {} ignored.",
                         std::source_location::current().function_name());
            return;
        }

        wnd = SDL_CreateWindow(title.c_str(), width, height, state);
        if (!wnd)
        {
            spdlog::error("Cant create SDL Window: {}", SDL_GetError());
            throw window_error("Window create error");
        }
        // Vulkan
        init_instance();
        init_surface();
        init_gpu();

        running = true;
    }
    void destroy()
    {
        if (!running)
        {
            return;
        }
        SDL_DestroyWindow(wnd);
        SDL_Vulkan_DestroySurface(instance, surface, nullptr);
        running = false;
    }
    void poll_event()
    {
        static SDL_Event event;

        while (SDL_PollEvent(&event))
        {
            if (event.type == SDL_EVENT_QUIT) [[unlikely]]
            {
                destroy();
                break;
            }
        }
    }

    [[nodiscard]] inline bool is_running() const { return running; }
    [[nodiscard]] inline bool is_fullscreen() const
    {
        return state & std::to_underlying(flag::FULLSCREEN);
    }

private:
    void init_instance()
    {

        const vk::ApplicationInfo app_info = {
            .pApplicationName   = constants::appdata::title.c_str(),
            .applicationVersion = vk::makeVersion(std::stoi(version::major),
                                                  std::stoi(version::minor),
                                                  std::stoi(version::patch)),
            .pEngineName        = constants::appdata::title.c_str(),
            .engineVersion      = vk::makeVersion(std::stoi(version::major),
                                             std::stoi(version::minor),
                                             std::stoi(version::patch)),
            .apiVersion         = vk::ApiVersion14
        };

        std::uint32_t count {};
        utils::vk_check(vk::enumerateInstanceLayerProperties(&count, nullptr));
        std::vector<vk::LayerProperties> avaliable_layers(count);
        utils::vk_check(vk::enumerateInstanceLayerProperties(
            &count, avaliable_layers.data()));

        std::vector<const char*> avaliable_layers_name;
        std::ranges::transform(avaliable_layers,
                               std::back_inserter(avaliable_layers_name),
                               [](const vk::LayerProperties& layer)
                               { return layer.layerName.data(); });

        utils::vk_check(
            vk::enumerateInstanceExtensionProperties(nullptr, &count, nullptr));
        std::vector<vk::ExtensionProperties> avaliable_extension(count);
        utils::vk_check(vk::enumerateInstanceExtensionProperties(
            nullptr, &count, avaliable_extension.data()));

        std::vector<const char*> avaliable_extension_name;
        std::ranges::transform(avaliable_extension,
                               std::back_inserter(avaliable_extension_name),
                               [](const vk::ExtensionProperties& ext)
                               { return ext.extensionName.data(); });

        instance_layers =
            filter_instance(requested_layers, avaliable_layers_name);
        instance_ext = filter_instance(requested_ext, avaliable_extension_name);

        const vk::InstanceCreateInfo instance_info = {
            .pApplicationInfo  = &app_info,
            .enabledLayerCount = static_cast<uint32_t>(instance_layers.size()),
            .ppEnabledLayerNames   = instance_layers.data(),
            .enabledExtensionCount = static_cast<uint32_t>(instance_ext.size()),
            .ppEnabledExtensionNames = instance_ext.data(),
        };
        utils::vk_check(vk::createInstance(&instance_info, nullptr, &instance));
    }
    void init_surface()
    {
        {
            VkSurfaceKHR vk_surface {};
            bool         success =
                SDL_Vulkan_CreateSurface(wnd, instance, nullptr, &vk_surface);
            if (!success)
            {
                spdlog::error("Cant create Vulkan Surface: {}", SDL_GetError());
                throw window_error("Vulkan Surface create error");
            }
            surface = vk_surface;
        }
    }
    void init_gpu()
    {
        uint32_t count {};
        utils::vk_check(instance.enumeratePhysicalDevices(&count, nullptr));
        phys_devices.resize(count);
        utils::vk_check(
            instance.enumeratePhysicalDevices(&count, phys_devices.data()));

        for (const auto& device : phys_devices)
        {
            spdlog::info("Device {}: \ndeviceID: "
                         "{}\nvendorID: {}\ndeviceType: "
                         "{}\ndriverVersion: {}",
                         device.getProperties().deviceName.data(),
                         device.getProperties().deviceID,
                         device.getProperties().vendorID,
                         vk::to_string(device.getProperties().deviceType),
                         device.getProperties().driverVersion);
        }
        current_gpu = platform::device::gpu(phys_devices[0], surface, {});

        // Always request a graphics queue
        current_gpu.reserve_queues(vk::QueueFlagBits::eGraphics, surface);

        // Create the device
        {
            const auto family_indices =
                current_gpu.queue_family_index_and_count();

            std::vector<vk::DeviceQueueCreateInfo> queue_create_infos;

            std::vector<std::vector<float>> priorities_for_all_families(
                family_indices.size());
            for (size_t index = 0;
                 const auto& [queueFamilyIndex, queueCount] : family_indices)
            {
                priorities_for_all_families[index] =
                    std::vector<float>(queueCount, 1.0f);
                queue_create_infos.emplace_back(vk::DeviceQueueCreateInfo {
                    .queueFamilyIndex = queueFamilyIndex,
                    .queueCount       = queueCount,
                    .pQueuePriorities =
                        priorities_for_all_families[index].data(),
                });
                ++index;
            }

            const vk::DeviceCreateInfo dci = {
                .queueCreateInfoCount =
                    static_cast<uint32_t>(queue_create_infos.size()),
                .pQueueCreateInfos = queue_create_infos.data(),
                // TODO: Fill exts
            };
            utils::vk_check(current_gpu.device().createDevice(
                &dci, nullptr, &logical_device));
        }

        if (current_gpu.graphics_family_enabled())
        {
            if (current_gpu.get_graphics_queue_count() > 0)
            {
                graphics_queues.resize(current_gpu.get_graphics_queue_count(),
                                       {});

                for (uint32_t i = 0; i < graphics_queues.size(); ++i)
                {
                    vk::DeviceQueueInfo2 info = {
                        .queueFamilyIndex =
                            current_gpu.get_graphics_family_index(),
                        .queueIndex = i,
                    };
                    logical_device.getQueue2(&info, &graphics_queues[i]);
                }
            }
        }
        if (current_gpu.compute_family_enabled())
        {
            if (current_gpu.get_compute_queue_count() > 0)
            {
                compute_queues.resize(current_gpu.get_compute_queue_count(),
                                      {});

                for (uint32_t i = 0; i < compute_queues.size(); ++i)
                {
                    vk::DeviceQueueInfo2 info = {
                        .queueFamilyIndex =
                            current_gpu.get_compute_family_index(),
                        .queueIndex = i,
                    };
                    logical_device.getQueue2(&info, &compute_queues[i]);
                }
            }
        }
    }
    std::vector<const char*> filter_instance(std::vector<const char*> requested,
                                             std::vector<const char*> avaliable)
    {
        std::ranges::sort(requested);
        std::ranges::sort(avaliable);
        std::vector<const char*> result;

        std::ranges::set_intersection(requested,
                                      avaliable,
                                      std::back_inserter(result),
                                      [](const char* a, const char* b)
                                      { return a == b; });

        return result;
    }

    std::string    title {};
    std::int32_t   width {};
    std::int32_t   height {};
    context::flags state {};

    bool running {};

    SDL_Window* wnd {};

    std::vector<const char*> instance_layers {};
    std::vector<const char*> instance_ext {};

    vk::Instance   instance {};
    vk::SurfaceKHR surface {};
    vk::Device     logical_device {};

    std::vector<const char*> requested_layers;
    std::vector<const char*> requested_ext;

    std::vector<vk::PhysicalDevice> phys_devices;
    std::vector<vk::Queue>          graphics_queues;
    std::vector<vk::Queue>          compute_queues;
    device::gpu                     current_gpu {};
};
} // namespace svl::platform::window